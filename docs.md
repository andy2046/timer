

# timer
`import "github.com/andy2046/timer"`

* [Overview](#pkg-overview)
* [Index](#pkg-index)
* [Examples](#pkg-examples)
* [Subdirectories](#pkg-subdirectories)

## <a name="pkg-overview">Overview</a>



## <a name="pkg-index">Index</a>
* [func After(d time.Duration) &lt;-chan time.Time](#After)
* [type Timer](#Timer)
  * [func AfterFunc(d time.Duration, f func()) *Timer](#AfterFunc)
  * [func New(d time.Duration) *Timer](#New)
  * [func (t *Timer) Reset(d time.Duration) bool](#Timer.Reset)
  * [func (t *Timer) Stop() bool](#Timer.Stop)

#### <a name="pkg-examples">Examples</a>
* [Timer](#example_Timer)

#### <a name="pkg-files">Package files</a>
[timer.go](/src/github.com/andy2046/timer/timer.go) 





## <a name="After">func</a> [After](/src/target/timer.go?s=1198:1242#L52)
``` go
func After(d time.Duration) <-chan time.Time
```
After waits for the duration to elapse and then sends the current time
on the returned channel.
It is equivalent to New(d).C.




## <a name="Timer">type</a> [Timer](/src/target/timer.go?s=189:245#L10)
``` go
type Timer struct {
    C <-chan time.Time
    // contains filtered or unexported fields
}
```
The Timer type represents a single event.
When the Timer expires, the current time will be sent on C,
unless the Timer was created by AfterFunc.







### <a name="AfterFunc">func</a> [AfterFunc](/src/target/timer.go?s=1434:1482#L59)
``` go
func AfterFunc(d time.Duration, f func()) *Timer
```
AfterFunc waits for the duration to elapse and then calls f
in its own goroutine. It returns a Timer that can
be used to cancel the call using its Stop method.


### <a name="New">func</a> [New](/src/target/timer.go?s=351:383#L17)
``` go
func New(d time.Duration) *Timer
```
New creates a new Timer that will send
the current time on its channel after at least duration d.





### <a name="Timer.Reset">func</a> (\*Timer) [Reset](/src/target/timer.go?s=901:944#L37)
``` go
func (t *Timer) Reset(d time.Duration) bool
```
Reset changes the timer to expire after duration d.
It returns true if the timer had been active, false if the timer had
expired or been stopped.




### <a name="Timer.Stop">func</a> (\*Timer) [Stop](/src/target/timer.go?s=694:721#L30)
``` go
func (t *Timer) Stop() bool
```
Stop prevents the Timer from firing.
It returns true if the call stops the timer, false if the timer has already
expired or been stopped.
Stop does not close the channel, to prevent a read from the channel succeeding
incorrectly.








- - -
Generated by [godoc2md](http://godoc.org/github.com/davecheney/godoc2md)
